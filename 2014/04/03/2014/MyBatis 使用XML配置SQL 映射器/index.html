<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="MyBatis," />





  <link rel="alternate" href="/atom.xml" title="I am cmp-cc" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="关系型数据库和 SQL 是经受时间考验和验证的数据存储机制。和其他的 ORM 框架如 Hibernate 不同，MyBatis鼓励开发者可以直接使用数据库，而不是将其对开发者隐藏，因为这样可以充分发挥数据库服务器所提供的 SQL 语句的巨大威力。与此同时，MyBaits 消除了书写大量冗余代码的痛苦，它使使用 SQL 更容易。
  在代码里直接嵌套 SQL 语句是很差的编码实践，并且维护起来困难。">
<meta property="og:type" content="article">
<meta property="og:title" content="MyBatis 使用XML配置SQL 映射器">
<meta property="og:url" content="http://cmp-cc.github.io/2014/04/03/2014/MyBatis 使用XML配置SQL 映射器/index.html">
<meta property="og:site_name" content="I am cmp-cc">
<meta property="og:description" content="关系型数据库和 SQL 是经受时间考验和验证的数据存储机制。和其他的 ORM 框架如 Hibernate 不同，MyBatis鼓励开发者可以直接使用数据库，而不是将其对开发者隐藏，因为这样可以充分发挥数据库服务器所提供的 SQL 语句的巨大威力。与此同时，MyBaits 消除了书写大量冗余代码的痛苦，它使使用 SQL 更容易。
  在代码里直接嵌套 SQL 语句是很差的编码实践，并且维护起来困难。">
<meta property="og:updated_time" content="2016-05-06T08:44:02.742Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MyBatis 使用XML配置SQL 映射器">
<meta name="twitter:description" content="关系型数据库和 SQL 是经受时间考验和验证的数据存储机制。和其他的 ORM 框架如 Hibernate 不同，MyBatis鼓励开发者可以直接使用数据库，而不是将其对开发者隐藏，因为这样可以充分发挥数据库服务器所提供的 SQL 语句的巨大威力。与此同时，MyBaits 消除了书写大量冗余代码的痛苦，它使使用 SQL 更容易。
  在代码里直接嵌套 SQL 语句是很差的编码实践，并且维护起来困难。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> MyBatis 使用XML配置SQL 映射器 | I am cmp-cc </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?0fb6f1a75a76726c10a144a8257465e3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">I am cmp-cc</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一直在打杂，从未被超越。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                MyBatis 使用XML配置SQL 映射器
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-04-03T11:09:00+08:00" content="2014-04-03">
              2014-04-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java-Web/" itemprop="url" rel="index">
                    <span itemprop="name">Java Web</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java-Web/MyBatis/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/04/03/2014/MyBatis 使用XML配置SQL 映射器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/04/03/2014/MyBatis 使用XML配置SQL 映射器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>关系型数据库和 SQL 是经受时间考验和验证的数据存储机制。和其他的 ORM 框架如 Hibernate 不同，MyBatis鼓励开发者可以直接使用数据库，而不是将其对开发者隐藏，因为这样可以充分发挥数据库服务器所提供的 SQL 语句的巨大威力。与此同时，MyBaits 消除了书写大量冗余代码的痛苦，它使使用 SQL 更容易。</p>
<p>  在代码里直接嵌套 SQL 语句是很差的编码实践，并且维护起来困难。MyBaits 使用了映射器配置文件或注解来配置 SQL语句。</p>
<p>我们会看到具体怎样使用映射器配置文件来配置映射 SQL 语句。</p>
<p>理解如下概念：</p>
<ul>
<li>映射器配置文件 和 映射器接口</li>
<li>映射语句<ul>
<li>配置 INSERT, UPDATE, DELETE, and SELECT 语句</li>
</ul>
</li>
<li>结果映射 ResultMaps<ul>
<li>简单 ResultMaps</li>
<li>使用内嵌 select 语句子查询的一对一映射</li>
<li>使用内嵌的结果集查询的一对一映射</li>
<li>使用内嵌 select 语句子查询的一对多映射</li>
<li>使用内嵌的结果集查询的一对一映射</li>
</ul>
</li>
<li>动态 SQL 语句<ul>
<li>If 条件</li>
<li>choose (when, otherwise) 条件</li>
<li>trim (where, set) 条件</li>
<li>foreach 循环</li>
</ul>
</li>
<li>MyBatis 菜谱</li>
</ul>
<h2 id="映射器配置文件和映射器接口"><a href="#映射器配置文件和映射器接口" class="headerlink" title="映射器配置文件和映射器接口"></a>映射器配置文件和映射器接口</h2><p>映射器配置文件中配置映射语句，然后使用SqlSession对象调用他们。如下:<br>StudentMapper.xml 配置文件内，是如何配置 id 为“findStudentById”的 SQL 语句的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;org.freecode.mappers.StudentMapper&quot;&gt;</span><br><span class="line">&lt;select id=&quot;findStudentById&quot; parameterType=&quot;int&quot; resultType=&quot;Student&quot;&gt;</span><br><span class="line">select stud_id as studId, name, email, dob</span><br><span class="line">from Students where stud_id=#&#123;studId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>我们可以通过下列代码调用 findStudentById 映射的 SQL 语句:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Student findStudentById2(Integer studId)&#123;</span><br><span class="line">		SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();</span><br><span class="line">		try&#123;</span><br><span class="line">			return (Student)sqlSession.selectOne(&quot;org.freecode.mappers.StudentMapper.findStudentById&quot;,studId);</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			sqlSession.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以通过字符串（字符串形式为：映射器配置文件所在的包名 namespace + 在文件内定义的语句 id，如上，即包名 org.freecode.mappers.StudentMapper 和语句 id findStudentById 组成）调用映射的 SQL 语句，但是这种方式容易出错。你需要检查映射器配置文件中的定义，以保证你的输入参数类型和结果返回类型是有效的。</p>
</blockquote>
<p>MyBatis 通过使用映射器 Mapper 接口提供了更好的调用映射语句的方法。一旦我们通过映射器配置文件配置了映射语句，我们可以创建一个完全对应的一个映射器接口，接口名跟配置文件名相同，接口所在包名也跟配置文件所在包名完全一样(如StudentMapper.xml所在的包名是org.freecode.mappers ， 对 应 的 接 口 名 就 是org.freecode.mappers.StudentMapper.java ）。映射器接口中的方法签名也跟映射器配置文件中完全对应：方法名为配置文件中 id 值；方法参数类型为 parameterType 对应值；方法返回值类型为 returnType 对应值。</p>
<p>对于上述的 StudentMapper.xml 文件，我们可以创建一个映射器接口 StudentMapper.java 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package org.freecode.mappers;</span><br><span class="line">public interface StudentMapper&#123;</span><br><span class="line">    Student findStudentById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 StudentMapper.xml 映射器配置文件中，其名空间 namespace 应该跟 StudentMapper 接口的完全限定名保持一致。另外，StudentMapper.xml 中语句 id，parameterType，returnType 应该分别和 StudentMapper 接口中的方法名，参数类型，返回值相对应。</p>
<p>使用映射器接口我们可以以类型安全的形式调用调用映射语句。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Student findStudentById(Integer studId)&#123;</span><br><span class="line">		SqlSession sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">		try&#123;</span><br><span class="line">			StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">			return studentMapper.findStudentById(studId);</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			sqlSession.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>即使映射器 Mapper 接口可以以类型安全的方式调用映射语句，但是我们我负责书写正确的，匹配方法名、参数类型、和返回值的映射器 Mapper 接口。 如果映射器 Mapper 接口中的方法和 XML 中的映射语句不能匹配，会在运行期 抛出一个异常。实际上，指定 parameterType 是可选的；MyBatis 可以使用反 射机制来决定 parameterType。但是，从配置可读性的角度来看，最好指定 parameterType 属性。如果 parameterType 没有被提及，开发者必须查看 Mapper XML 配置和 Java 代码了解传递给语句的输入参数的数据类型。</p>
</blockquote>
<h2 id="映射语句"><a href="#映射语句" class="headerlink" title="映射语句"></a>映射语句</h2><p><strong>MyBatis 提供了多种元素来配置不同类型的语句，如 SELECT，INSERT，UPDATE，DELETE。接下来让我们看看如何具体配置映射语句</strong></p>
<h3 id="INSERT-语句"><a href="#INSERT-语句" class="headerlink" title="INSERT 语句"></a>INSERT 语句</h3><p>一个 INSERT SQL 语句可以在<insert>元素在映射器 XML 配置文件中配置，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertStudent&quot; parameterType=&quot;Student&quot;&gt;</span><br><span class="line">     INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL, PHONE) VALUES(#&#123;studId&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;phone&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure></insert></p>
<p>这里我们使用一个 ID insertStudent，可以在名空间 org.freecode.mappers.StudentMapper.insertStudent 中唯一标识。parameterType 属性应该是一个完全限定类名或者是一个类型别名（alias）。</p>
<p>我们可以如下调用这个语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = sqlSession.insert(&quot;org.freecode.mappers.StudentMapper.insertStudent&quot;, student);</span><br></pre></td></tr></table></figure></p>
<p>sqlSession.insert() 方法返回执行 INSERT 语句后所影响的行数。</p>
<p>如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package org.freecode.mappers;</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line">  int insertStudent(Student student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以如下调用 insertStudent 映射语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">int count = mapper.insertStudent(student);</span><br></pre></td></tr></table></figure></p>
<p><strong>自动生成主键</strong></p>
<p>在上述的 INSERT 语句中，我们为可以自动生成（auto-generated）主键的列 STUD_ID 插入值。我们可以使用useGeneratedKeys 和 keyProperty 属性让数据库生成 auto_increment 列的值，并将生成的值设置到其中一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertStudent&quot; parameterType=&quot;Student&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;studId&quot;&gt;</span><br><span class="line">    INSERT INTO STUDENTS(NAME, EMAIL, PHONE) VALUES(#&#123;name&#125;,#&#123;email&#125;,#&#123;phone&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<p>这里 STUD_ID 列值将会被 MySQL 数据库自动生成，并且生成的值会被设置到 student 对象的 studId 属性上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">mapper.insertStudent(student);</span><br></pre></td></tr></table></figure></p>
<p>现在可以如下获取插入的 STUDENT 记录的 STUD_ID 的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int studentId = student.getStudId();</span><br></pre></td></tr></table></figure></p>
<p>有些数据库如 Oracle 并不支持 AUTO_INCREMENT 列，其使用序列（SEQUENCE）来生成主键值。<br>假设我们有一个名为 STUD_ID_SEQ 的序列来生成 SUTD_ID 主键值。使用如下代码来生成主键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertStudent&quot; parameterType=&quot;Student&quot;&gt;</span><br><span class="line">    &lt;selectKey keyProperty=&quot;studId&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;</span><br><span class="line">        SELECT ELEARNING.STUD_ID_SEQ.NEXTVAL FROM DUAL</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL, PHONE) VALUES(#&#123;studId&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;phone&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure></p>
<p>   这里我们使用了<selectkey>子元素来生成主键值，并将值保存到 Student 对象的 studId 属性上。 属性order=“before”表示 MyBatis 将取得序列的下一个值作为主键值，并且在执行 INSERT SQL 语句之前将值设置到studId 属性上。</selectkey></p>
<p>   我们也可以在获取序列的下一个值时，使用触发器（trigger）来设置主键值，并且在执行 INSERT SQL 语句之<br>前将值设置到主键列上。如果你采取这样的方式，则对应的 INSERT 映射语句如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertStudent&quot; parameterType=&quot;Student&quot;&gt;</span><br><span class="line">    INSERT INTO STUDENTS(NAME,EMAIL, PHONE) VALUES(#&#123;name&#125;,#&#123;email&#125;,#&#123;phone&#125;)</span><br><span class="line">    &lt;selectKey keyProperty=&quot;studId&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;</span><br><span class="line">        SELECT ELEARNING.STUD_ID_SEQ.CURRVAL FROM DUAL</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="UPDATE-语句"><a href="#UPDATE-语句" class="headerlink" title="UPDATE 语句"></a>UPDATE 语句</h3><p>一个 UPDATE SQL 语句可以在<update>元素在映射器 XML 配置文件中配置，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateStudent&quot; parameterType=&quot;Student&quot;&gt;</span><br><span class="line">     UPDATE STUDENTS SET NAME=#&#123;name&#125;, EMAIL=#&#123;email&#125;, PHONE=#&#123;phone&#125; WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></update></p>
<p>我们可以如下调用此语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int noOfRowsUpdated = sqlSession.update(&quot;org.freecode.mappers.StudentMapper.updateStudent&quot;, student);</span><br></pre></td></tr></table></figure>
<p>sqlSession.update() 方法返回执行 UPDATE 语句之后影响的行数。</p>
<p>  如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package org.freecode.mappers;</span><br><span class="line">public interface StudentMapper</span><br><span class="line">&#123;</span><br><span class="line">	int updateStudent(Student student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用映射器 Mapper 接口来调用 updateStudent 语句，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">int noOfRowsUpdated = mapper.updateStudent(student);</span><br></pre></td></tr></table></figure>
<h3 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h3><p>一个 UPDATE SQL 语句可以在<update>元素在映射器 XML 配置文件中配置，如下所示：</update></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">   DELETE FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以如下调用此语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int studId = 1;</span><br><span class="line">int noOfRowsDeleted = sqlSession.delete(&quot;org.freecode.mappers.StudentMapper.deleteStudent&quot;, studId);</span><br></pre></td></tr></table></figure></p>
<p>sqlSession.delete() 方法返回 delete 语句执行后影响的行数。</p>
<p>   如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package org.freecode.mappers;</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line">	int deleteStudent(int studId); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用映射器 Mapper 接口来调用 updateStudent 语句，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">int noOfRowsDeleted = mapper.deleteStudent(studId);</span><br></pre></td></tr></table></figure>
<h3 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h3><p>MyBatis 真正强大的功能，在于映射 SELECT 查询结果到 JavaBeans 方面的极大灵活性。<br>让我们看看一个简单的 select 查询是如何（在 MyBatis 中）配置的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findStudentById&quot; parameterType=&quot;int&quot; resultType=&quot;Student&quot;&gt;</span><br><span class="line">	SELECT STUD_ID, NAME, EMAIL, PHONE FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们可以如下调用此语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int studId =1;</span><br><span class="line">Student student = sqlSession.selectOne(&quot;org.freecode.mappers.</span><br><span class="line">StudentMapper.findStudentById&quot;, studId);</span><br></pre></td></tr></table></figure></p>
<p>  如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package org.freecode.mappers;</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line">	Student findStudentById(Integer studId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用映射器 Mapper 接口来调用 updateStudent 语句，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">Student student = mapper.findStudentById(studId);</span><br></pre></td></tr></table></figure></p>
<p>如果你检查 Student 对象的属性值，你会发现 studId 属性值并没有被 stud_id 列值填充。这是因为 MyBatis 自动对JavaBean 中和列名匹配的属性进行填充。这就是为什么 name ,email,和 phone 属性被填充，而 studId 属性没有被填充。</p>
<p>  为了解决这一问题，我们可以为列名起一个可以与 JavaBean 中属性名匹配的别名，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findStudentById&quot; parameterType=&quot;int&quot; resultType=&quot;Student&quot;&gt;</span><br><span class="line">SELECT STUD_ID AS studId, NAME,EMAIL, PHONE FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>现在，Student 这个 Bean 对象中的值将会恰当地被 stud_id,name,email,phone 列填充了。<br>现在，让我们看一下如何执行返回多条结果的 SELECT 语句查询，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findAllStudents&quot; resultType=&quot;Student&quot;&gt;</span><br><span class="line">	SELECT STUD_ID AS studId, NAME,EMAIL, PHONE FROM STUDENTS</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = sqlSession.selectList(&quot;org.freecode.mappers.StudentMapper.findAllStudents&quot;);</span><br></pre></td></tr></table></figure>
<p>映射器 Mapper 接口 StudentMapper 可以如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package org.freecode.mappers;</span><br><span class="line">public interface StudentMapper</span><br><span class="line">&#123;</span><br><span class="line">	List&lt;Student&gt; findAllStudents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上述代码，我们可以如下调用 findAllStudents 语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">List&lt;Student&gt; students = mapper.findAllStudents();</span><br></pre></td></tr></table></figure></p>
<p>如果你注意到上述的 SELECT 映射定义，你可以看到，我们为所有的映射语句中的 stud_id 起了别名。<br>我们可以使用 ResultMaps，来避免上述的到处重复别名。我们稍后会继续讨论。<br>除了 java.util.List，你也可以是由其他类型的集合类，如 Set,Map，以及（SortedSet）。MyBatis 根据集合的类型，会采用适当的集合实现，如下所示：</p>
<ul>
<li>对于 List，Collection，Iterable 类型，MyBatis 将返回 java.util.ArrayList</li>
<li>对于 Map 类型，MyBatis 将返回 java.util.HashMap</li>
<li>对于 Set 类型，MyBatis 将返回 java.util.HashSet</li>
<li>对于 SortedSet 类型，MyBatis 将返回 java.util.TreeSet</li>
</ul>
<h2 id="结果集映射-ResultMaps"><a href="#结果集映射-ResultMaps" class="headerlink" title="结果集映射 ResultMaps"></a>结果集映射 ResultMaps</h2><p>ResultMaps 被用来 将 SQL SELECT 语句的结果集映射到 JavaBeans 的属性中。我们可以定义结果集映射 ResultMaps并且在一些 SELECT 语句上引用 resultMap。MyBatis 的结果集映射 ResultMaps 特性非常强大，你可以使用它将简单的SELECT 语句映射到复杂的一对一和一对多关系的 SELECT 语句上。</p>
<h3 id="简单-ResultMap"><a href="#简单-ResultMap" class="headerlink" title="简单 ResultMap"></a>简单 ResultMap</h3><p>一个映射了查询结果和 Student JavaBean 的简单的 resultMap 定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;StudentResult&quot; type=&quot;org.freecode.domain.Student&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;studId&quot; column=&quot;stud_id&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;phone&quot; column=&quot;phone&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findStudentById&quot; parameterType=&quot;int&quot; resultMap=&quot;StudentResult&quot;&gt;</span><br><span class="line">	SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;select id=&quot;findAllStudents&quot; resultMap=&quot;StudentResult&quot;&gt;</span><br><span class="line">	SELECT * FROM STUDENTS</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>表示 resultMap 的 StudentResult id 值应该在此名空间内是唯一的。并且 type 属性应该是完全限定类名或者是返回类型的别名。<br><code>&lt;result&gt;</code>子元素被用来将一个 resultset 列映射到 JavaBean 的一个属性中。</p>
<p>  <code>&lt;id&gt;</code>元素和<code>&lt;result&gt;</code>元素功能相同，不过它被用来映射到唯一标识属性，用来区分和比较对象（一般和主键列相对应）。</p>
<p>在<code>&lt;select&gt;</code>语句中，我们使用了 resultMap 属性，而不是 resultType 来引用 StudentResult 映射。当<code>&lt;select&gt;</code>语句中配置了 resutlMap 属性，MyBatis 会使用此数据库列名与对象属性映射关系来填充 JavaBean 中的属性。</p>
<blockquote>
<p>resultType 和 resultMap 二者只能用其一，不能同时使用。</p>
</blockquote>
<p>让我们来看另外一个<code>&lt;select&gt;</code>映射语句定义的例子，怎样将查询结果填充到 HashMap 中。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findStudentById&quot; parameterType=&quot;int&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">	SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>在上述的<code>&lt;select&gt;</code>语句中，我们将 resultType 配置成 map，即 java.util.HashMap 的别名。在这种情况下，结果集<br>的列名将会作为 Map 中的 key 值，而列值将作为 Map 的 value 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,Object&gt; studentMap = sqlSession.selectOne(&quot;org.freecode.mappers.StudentMapper.findStudentById&quot;, studId);</span><br><span class="line">System.out.println(&quot;stud_id :&quot;+studentMap.get(&quot;stud_id&quot;));</span><br><span class="line">System.out.println(&quot;name :&quot;+studentMap.get(&quot;name&quot;));</span><br><span class="line">System.out.println(&quot;email :&quot;+studentMap.get(&quot;email&quot;));</span><br><span class="line">System.out.println(&quot;phone :&quot;+studentMap.get(&quot;phone&quot;));</span><br></pre></td></tr></table></figure>
<p>让我们再看一个 使用 resultType=”map”,返回多行结果的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findAllStudents&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">	SELECT STUD_ID, NAME, EMAIL, PHONE FROM STUDENTS</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>由于 resultType=”map”和语句返回多行，则最终返回的数据类型应该是<code>List&lt;HashMap&lt;String,Object&gt;&gt;</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; studentMapList =</span><br><span class="line">sqlSession.selectList(&quot;org.freecode.mappers.StudentMapper.findAllStudents&quot;);</span><br><span class="line">for(HashMap&lt;String, Object&gt; studentMap : studentMapList)&#123;</span><br><span class="line">	System.out.println(&quot;studId :&quot; + studentMap.get(&quot;stud_id&quot;));</span><br><span class="line">	System.out.println(&quot;name :&quot; + studentMap.get(&quot;name&quot;));</span><br><span class="line">	System.out.println(&quot;email :&quot; + studentMap.get(&quot;email&quot;));</span><br><span class="line">	System.out.println(&quot;phone :&quot; + studentMap.get(&quot;phone&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展-ResultMap"><a href="#拓展-ResultMap" class="headerlink" title="拓展 ResultMap"></a>拓展 ResultMap</h3><p>我们可以从从另外一个<code>&lt;resultMap&gt;</code>，拓展出一个新的<code>&lt;resultMap&gt;</code>，这样，原先的属性映射可以继承过来，以实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;Student&quot; id=&quot;StudentResult&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;studId&quot; column=&quot;stud_id&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;phone&quot; column=&quot;phone&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;resultMap type=&quot;Student&quot; id=&quot;StudentWithAddressResult&quot; extends=&quot;StudentResult&quot;&gt;</span><br><span class="line">	&lt;result property=&quot;address.addrId&quot; column=&quot;addr_id&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;address.street&quot; column=&quot;street&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;address.city&quot; column=&quot;city&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;address.state&quot; column=&quot;state&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;address.zip&quot; column=&quot;zip&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;address.country&quot; column=&quot;country&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></p>
<p>id 为 StudentWithAddressResult 的 resultMap 拓展了 id 为 StudentResult 的 resultMap。</p>
<p>如果你只想映射 Student 数据，你可以使用 id 为 StudentResult 的 resultMap,如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findStudentById&quot; parameterType=&quot;int&quot; resultMap=&quot;StudentResult&quot;&gt;</span><br><span class="line">	SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果你想将映射 Student 数据和 Address 数据，你可以使用 id 为 StudentWithAddressResult 的 resultMap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectStudentWithAddress&quot; parameterType=&quot;int&quot; resultMap=&quot;StudentWithAddressResult&quot;&gt;</span><br><span class="line">	SELECT STUD_ID, NAME, EMAIL, PHONE, A.ADDR_ID, STREET, CITY, STATE, ZIP, COUNTRY</span><br><span class="line">		FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON</span><br><span class="line">		S.ADDR_ID=A.ADDR_ID</span><br><span class="line">		WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="一对一映射"><a href="#一对一映射" class="headerlink" title="一对一映射"></a>一对一映射</h2><p>在我们的域模型样例中，每一个学生都有一个与之关联的地址信息。表 STUDENTS 有一个 ADDR_ID 列，是 ADDRESSES表的外键。<br>STUDENTS 表的样例数据如下所示：</p>
<table>
<thead>
<tr>
<th>STUD_ID</th>
<th>NAME</th>
<th>EMAIL</th>
<th>PHONE</th>
<th>ADDR_ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>John</td>
<td>john@gmail.com</td>
<td>123-456-7890</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Paul</td>
<td>paul@gmail.com</td>
<td>111-222-3333</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>ADDRESSES 表的样例输入如下所示：</p>
<table>
<thead>
<tr>
<th>ADDR_ID</th>
<th>STREET</th>
<th>CITY</th>
<th>STATE</th>
<th>ZIP</th>
<th>COUNTRY</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Naperville</td>
<td>CHICAGO</td>
<td>IL</td>
<td>60515</td>
<td>USA</td>
</tr>
<tr>
<td>2</td>
<td>Paul</td>
<td>CHICAGO</td>
<td>IL</td>
<td>60515</td>
<td>USA</td>
</tr>
</tbody>
</table>
<p>下面让我们看一下怎样取 Student 明细和其 Address 明细。</p>
<p>Student 和 Address 的 JavaBean 以及映射器 Mapper XML 文件定义如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Address &#123;</span><br><span class="line">	private Integer addrId;</span><br><span class="line">	private String street;</span><br><span class="line">	private String city;</span><br><span class="line">	private String state;</span><br><span class="line">	private String zip;</span><br><span class="line">	private String country;</span><br><span class="line">	// setters &amp; getters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">	private Integer studId;</span><br><span class="line">	private String name;</span><br><span class="line">	private String email;</span><br><span class="line">	private PhoneNumber phone;</span><br><span class="line">	private Address address;</span><br><span class="line">	//setters &amp; getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;Student&quot; id=&quot;StudentWithAddressResult&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;studId&quot; column=&quot;stud_id&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;phone&quot; column=&quot;phone&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;address.addrId&quot; column=&quot;addr_id&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;address.street&quot; column=&quot;street&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;address.city&quot; column=&quot;city&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;address.state&quot; column=&quot;state&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;address.zip&quot; column=&quot;zip&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;address.country&quot; column=&quot;country&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectStudentWithAddress&quot; parameterType=&quot;int&quot; resultMap=&quot;StudentWithAddressResult&quot;&gt;</span><br><span class="line">SELECT STUD_ID, NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE,</span><br><span class="line">ZIP, COUNTRY</span><br><span class="line">FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON</span><br><span class="line">S.ADDR_ID=A.ADDR_ID WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以使用圆点记法为内嵌的对象的属性赋值。在上述的 resultMap 中，Student 的 address 属性使用了圆点记法被赋上了 address 对应列的值。同样地，我们可以访问任意深度的内嵌对象的属性。我们可以如下访问内嵌对象属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//接口定义</span><br><span class="line">public interface StudentMapper&#123;</span><br><span class="line">	Student selectStudentWithAddress(int studId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">int studId = 1;</span><br><span class="line"> </span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">Student student = studentMapper.selectStudentWithAddress(studId);</span><br><span class="line">System.out.println(&quot;Student :&quot; + student);</span><br><span class="line">System.out.println(&quot;Address :&quot; + student.getAddress());</span><br></pre></td></tr></table></figure></p>
<p>上述样例展示了一对一关联映射的一种方法。然而，使用这种方式映射，如果 address 结果需要在其他的 SELECT 映射语句中映射成 Address 对象，我们需要为每一个语句重复这种映射关系。MyBatis 提供了更好地实现一对一关联映射的方法：嵌套结果 ResultMap 和嵌套 select 查询语句。接下来，我们将讨论这两种方式。</p>
<h3 id="使用嵌套结果-ResultMap-实现一对一关系映射"><a href="#使用嵌套结果-ResultMap-实现一对一关系映射" class="headerlink" title="使用嵌套结果 ResultMap 实现一对一关系映射"></a>使用嵌套结果 ResultMap 实现一对一关系映射</h3><p>我们可以使用一个嵌套结果 ResultMap 方式来获取 Student 及其 Address 信息，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;resultMap type=&quot;Address&quot; id=&quot;AddressResult&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;addrId&quot; column=&quot;addr_id&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;street&quot; column=&quot;street&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;city&quot; column=&quot;city&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;state&quot; column=&quot;state&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;zip&quot; column=&quot;zip&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;country&quot; column=&quot;country&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap type=&quot;Student&quot; id=&quot;StudentWithAddressResult&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;studId&quot; column=&quot;stud_id&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;</span><br><span class="line">    &lt;association property=&quot;address&quot; resultMap=&quot;AddressResult&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findStudentWithAddress&quot; parameterType=&quot;int&quot; resultMap=&quot;StudentWithAddressResult&quot;&gt;</span><br><span class="line">SELECT STUD_ID, NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE,</span><br><span class="line">ZIP, COUNTRY</span><br><span class="line">FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON</span><br><span class="line">S.ADDR_ID=A.ADDR_ID WHERE STUD_ID=#&#123;studId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>  元素<association>被用来导入“有一个”(has-one)类型的关联。在上述的例子中，我们使用了<association>元素引用了另外的在同一个 XML 文件中定义的<resultmap>。</resultmap></association></association></p>
<p>我们也可以使用&lt;association 定义内联的 resultMap，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;Student&quot; id=&quot;StudentWithAddressResult&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;studId&quot; column=&quot;stud_id&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;</span><br><span class="line">	&lt;association property=&quot;address&quot; javaType=&quot;Address&quot;&gt;</span><br><span class="line">		&lt;id property=&quot;addrId&quot; column=&quot;addr_id&quot; /&gt;</span><br><span class="line">		&lt;result property=&quot;street&quot; column=&quot;street&quot; /&gt;</span><br><span class="line">		&lt;result property=&quot;city&quot; column=&quot;city&quot; /&gt;</span><br><span class="line">		&lt;result property=&quot;state&quot; column=&quot;state&quot; /&gt;</span><br><span class="line">		&lt;result property=&quot;zip&quot; column=&quot;zip&quot; /&gt;</span><br><span class="line">		&lt;result property=&quot;country&quot; column=&quot;country&quot; /&gt;</span><br><span class="line">	&lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<p>使用嵌套结果 ResultMap 方式，关联的数据可以通过简单的查询语句（如果需要的话，需要与 joins 连接操作配合）<br>进行加载。</p>
<h3 id="使用嵌套查询实现一对一关系映射"><a href="#使用嵌套查询实现一对一关系映射" class="headerlink" title="使用嵌套查询实现一对一关系映射"></a>使用嵌套查询实现一对一关系映射</h3><p>我们可以通过使用嵌套 select 查询来获取 Student 及其 Address 信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;Address&quot; id=&quot;AddressResult&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;addrId&quot; column=&quot;addr_id&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;street&quot; column=&quot;street&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;city&quot; column=&quot;city&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;state&quot; column=&quot;state&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;zip&quot; column=&quot;zip&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;country&quot; column=&quot;country&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findAddressById&quot; parameterType=&quot;int&quot; resultMap=&quot;AddressResult&quot;&gt;</span><br><span class="line">	SELECT * FROM ADDRESSES WHERE ADDR_ID=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap type=&quot;Student&quot; id=&quot;StudentWithAddressResult&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;studId&quot; column=&quot;stud_id&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;</span><br><span class="line">	&lt;association property=&quot;address&quot; column=&quot;addr_id&quot; select=&quot;findAddressById&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findStudentWithAddress&quot; parameterType=&quot;int&quot; resultMap=&quot;StudentWithAddressResult&quot;&gt;</span><br><span class="line">	SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;Id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>在此方式中，<association>元素的 select 属性被设置成了 id 为 findAddressById 的语句。这里，两个分开的SQL 语句将会在数据库中执行，第一个调用 findStudentById 加载 student 信息，而第二个调用 findAddressById 来加载 address 信息。</association></p>
<p>Addr_id 列的值将会被作为输入参数传递给 selectAddressById 语句。</p>
<p>我们可以如下调用 findStudentWithAddress 映射语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">Student student = mapper.selectStudentWithAddress(studId);</span><br><span class="line">System.out.println(student);</span><br><span class="line">System.out.println(student.getAddress());</span><br></pre></td></tr></table></figure></p>
<h2 id="一对多映射"><a href="#一对多映射" class="headerlink" title="一对多映射"></a>一对多映射</h2><p>在我们的域模型样例中，一个讲师可以教授一个或者多个课程。这意味着讲师和课程之间存在一对多的映射关系。<br>我们可以使用<collection>元素将 一对多类型的结果 映射到 一个对象集合上。<br>TUTORS 表的样例数据如下：<br>TUTOR_ID | NAME | EMAIL | PHONE |   ADDR_ID<br>— | — | — |—|—<br>1 | John| john@gmail.com| 123-456-7890| 1<br>2 |Ying |ying@gmail.com |111-222-3333 |2 </collection></p>
<p>COURSE 表的样例数据如下：</p>
<table>
<thead>
<tr>
<th>COURSE_ID</th>
<th>NAME</th>
<th>DESCRIPTION</th>
<th>START_DATE</th>
<th>END_DATE</th>
<th>TUTOR_ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>JavaSE</td>
<td>Java SE</td>
<td>2013-01-10</td>
<td>2013-02-10</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>JavaEE</td>
<td>Java EE 6</td>
<td>2013-01-10</td>
<td>2013-03-10</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>MyBatis</td>
<td>MyBatis</td>
<td>2013-01-10</td>
<td>2013-02-20</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>在上述的表数据中，John 讲师教授一个课程，而 Ying 讲师教授两个课程。</p>
<p>Course 和 Tutor 的 JavaBean 定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Tutor &#123;</span><br><span class="line">	private Integer tutorId;</span><br><span class="line">	private String name;</span><br><span class="line">	private String email;</span><br><span class="line">	private Address address;</span><br><span class="line">	private List&lt;Course&gt; courses;</span><br><span class="line">	// setters &amp; getters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Course &#123;</span><br><span class="line">	private Integer courseId;</span><br><span class="line">	private String name;</span><br><span class="line">	private String description;</span><br><span class="line">	private Date startDate;</span><br><span class="line">	private Date endDate;</span><br><span class="line">	private Integer tutorId;</span><br><span class="line">	//setters &amp; getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在让我们看看如何获取讲师信息以及其所教授的课程列表信息。<collection>元素被用来将多行课程结果映射成一个课程 Course 对象的一个集合。和一对一映射一样，我们可以使用嵌套结果 ResultMap 和嵌套 Select 语句两种方式映射实现一对多映射。</collection></p>
<h3 id="使用内嵌结果-ResultMap-实现一对多映射"><a href="#使用内嵌结果-ResultMap-实现一对多映射" class="headerlink" title="使用内嵌结果 ResultMap 实现一对多映射"></a>使用内嵌结果 ResultMap 实现一对多映射</h3><p>我们可以使用嵌套结果 resultMap 方式获得讲师及其课程信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;Course&quot; id=&quot;CourseResult&quot;&gt;</span><br><span class="line">	&lt;id column=&quot;course_id&quot; property=&quot;courseId&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;description&quot; property=&quot;description&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;start_date&quot; property=&quot;startDate&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;end_date&quot; property=&quot;endDate&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap type=&quot;Tutor&quot; id=&quot;TutorResult&quot;&gt;</span><br><span class="line">	&lt;id column=&quot;tutor_id&quot; property=&quot;tutorId&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;tutor_name&quot; property=&quot;name&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;</span><br><span class="line">	&lt;collection property=&quot;courses&quot; resultMap=&quot;CourseResult&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findTutorById&quot; parameterType=&quot;int&quot; resultMap=&quot;TutorResult&quot;&gt;</span><br><span class="line">	SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL, C.COURSE_ID,</span><br><span class="line">	C.NAME, DESCRIPTION, START_DATE, END_DATE</span><br><span class="line">	FROM TUTORS T LEFT OUTER JOIN ADDRESSES A ON T.ADDR_ID=A.ADDR_ID</span><br><span class="line">	LEFT OUTER JOIN COURSES C ON T.TUTOR_ID=C.TUTOR_ID</span><br><span class="line">	WHERE T.TUTOR_ID=#&#123;tutorId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>这里我们使用了一个简单的使用了 JOINS 连接的 Select 语句获取讲师及其所教课程信息。<collection>元素的<br>resultMap 属性设置成了 CourseResult，CourseResult 包含了 Course 对象属性与表列名之间的映射。</collection></p>
<h3 id="使用嵌套-Select-语句实现一对多映射"><a href="#使用嵌套-Select-语句实现一对多映射" class="headerlink" title="使用嵌套 Select 语句实现一对多映射"></a>使用嵌套 Select 语句实现一对多映射</h3><p>我们可以使用嵌套 Select 语句方式获得讲师及其课程信息，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;Course&quot; id=&quot;CourseResult&quot;&gt;</span><br><span class="line">	&lt;id column=&quot;course_id&quot; property=&quot;courseId&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;description&quot; property=&quot;description&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;start_date&quot; property=&quot;startDate&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;end_date&quot; property=&quot;endDate&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;resultMap type=&quot;Tutor&quot; id=&quot;TutorResult&quot;&gt;</span><br><span class="line">	&lt;id column=&quot;tutor_id&quot; property=&quot;tutorId&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;tutor_name&quot; property=&quot;name&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;</span><br><span class="line">	&lt;association property=&quot;address&quot; resultMap=&quot;AddressResult&quot; /&gt;</span><br><span class="line">	&lt;collection property=&quot;courses&quot; column=&quot;tutor_id&quot; select=&quot;findCoursesByTutor&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findTutorById&quot; parameterType=&quot;int&quot; resultMap=&quot;TutorResult&quot;&gt;</span><br><span class="line">	SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL FROM TUTORS T WHERE T.TUTOR_ID=#&#123;tutorId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findCoursesByTutor&quot; parameterType=&quot;int&quot; resultMap=&quot;CourseResult&quot;&gt;</span><br><span class="line">	SELECT * FROM COURSES WHERE TUTOR_ID=#&#123;tutorId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>在这种方式中，<aossication>元素的 select 属性被设置为 id 为 findCourseByTutor 的语句，用来触发单独的 SQL 查询加载课程信息。tutor_id 这一列值将会作为输入参数传递给 findCouresByTutor 语句。</aossication></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface TutorMapper &#123;</span><br><span class="line">	Tutor findTutorById(int tutorId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TutorMapper mapper = sqlSession.getMapper(TutorMapper.class);</span><br><span class="line">Tutor tutor = mapper.findTutorById(tutorId);</span><br><span class="line">System.out.println(tutor);</span><br><span class="line">List&lt;Course&gt; courses = tutor.getCourses();</span><br><span class="line">for (Course course : courses)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(course);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>嵌套 Select 语句查询会导致 N+1 选择问题。首先，主查询将会执行（1 次），对于主查询返回的每一行，另外一个查询将会被执行（主查询 N 行，则此查询 N 次）。对于大型数据库而言，这会导致很差的性能问题。</p>
<h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h2><p>有时候，静态的 SQL 语句并不能满足应用程序的需求。我们可以根据一些条件，来动态地构建 SQL 语句。</p>
</blockquote>
<p>例如，在 Web 应用程序中，有可能有一些搜索界面，需要输入一个或多个选项，然后根据这些已选择的条件去执行检索操作。在实现这种类型的搜索功能，我们可能需要根据这些条件 来构建动态的 SQL 语句。如果用户提供了任何输入条件，我们需要将那个条件 添加到 SQL 语句的 WHERE 子句中。MyBatis 通过使用<code>&lt;if&gt;</code>,<code>&lt;choose&gt;</code>,<code>&lt;where&gt;</code>,<code>&lt;foreach&gt;</code>,<code>&lt;trim&gt;</code>元素提供了对构造动态 SQL 语句的高级别支持。</p>
<h3 id="If-条件"><a href="#If-条件" class="headerlink" title="If 条件"></a>If 条件</h3><p>   <code>&lt;if&gt;</code>元素被用来有条件地嵌入 SQL 片段，如果测试条件被赋值为 true，则相应地 SQL 片段将会被添加到 SQL 语<br>句中。<br>   假定我们有一个课程搜索界面，设置了 讲师（Tutor）下拉列表框，课程名称（CourseName）文本输入框，开始<br>时间（StartDate）输入框，结束时间（EndDate）输入框，作为搜索条件。假定课讲师下拉列表是必须选的，其他的都是可选的。</p>
<p>当用户点击 搜索 按钮时，我们需要显示符合以下条件的成列表：</p>
<ul>
<li>特定讲师的课程</li>
<li>课程名 包含输入的课程名称关键字的课程；如果课程名称输入为空，则取所有课程</li>
<li>在开始时间和结束时间段内的课程</li>
</ul>
<p>我们可以对应的映射语句，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;resultMap type=&quot;Course&quot; id=&quot;CourseResult&quot;&gt;</span><br><span class="line">&lt;id column=&quot;course_id&quot; property=&quot;courseId&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;description&quot; property=&quot;description&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;start_date&quot; property=&quot;startDate&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;end_date&quot; property=&quot;endDate&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;searchCourses&quot; parameterType=&quot;hashmap&quot; resultMap=&quot;CourseResult&quot;&gt;&lt;/select&gt;</span><br><span class="line">	SELECT * FROM COURSES WHERE TUTOR_ID= #&#123;tutorId&#125;</span><br><span class="line">	&lt;if test=&quot;courseName != null&quot;&gt;</span><br><span class="line">		AND NAME LIKE #&#123;courseName&#125;</span><br><span class="line">	&lt;/if&gt;</span><br><span class="line">	&lt;if test=&quot;startDate != null&quot;&gt;</span><br><span class="line">		AND START_DATE &gt;= #&#123;startDate&#125;</span><br><span class="line">	&lt;/if&gt;</span><br><span class="line">	&lt;if test=&quot;endDate != null&quot;&gt;</span><br><span class="line">		AND END_DATE &lt;= #&#123;endDate&#125;</span><br><span class="line">	&lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface CourseMapper &#123;</span><br><span class="line">	List&lt;Course&gt; searchCourses(Map&lt;String, Object&gt; map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void searchCourses() &#123;</span><br><span class="line">	Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">	map.put(&quot;tutorId&quot;, 1);</span><br><span class="line">	map.put(&quot;courseName&quot;, &quot;%java%&quot;);</span><br><span class="line">	map.put(&quot;startDate&quot;, new Date());</span><br><span class="line">	CourseMapper mapper = sqlSession.getMapper(CourseMapper.class);</span><br><span class="line">	List&lt;Course&gt; courses = mapper.searchCourses(map);</span><br><span class="line">	for (Course course : courses) &#123;</span><br><span class="line">		System.out.println(course);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>此处将生成查询语句 SELECT * FROM COURSES WHERE TUTOR_ID= ? AND NAME like ? AND START_DATE &gt;= ?。准备根据给定条件的动态 SQL 查询将会派上用场。</p>
<blockquote>
<p>MyBatis 是使用 OGNL（Object Graph Navigation Language）表达式来构建动态 SQL 语句。</p>
</blockquote>
<h3 id="choose-when-和-otherwise-条件"><a href="#choose-when-和-otherwise-条件" class="headerlink" title="choose,when 和 otherwise 条件"></a>choose,when 和 otherwise 条件</h3><p>有时候，查询功能是以查询类别为基础的。首先，用户需要选择是否希望通过选择 讲师，课程名称，开始时间，或结束时间作为查询条件类别来进行查询，然后根据选择的查询类别，输入相应的参数。在这样的情景中，我们需要只使用其中一种查询类别。</p>
<p>MyBatis 提供了<code>&lt;choose&gt;</code>元素支持此类型的 SQL 预处理。</p>
<p>  现在让我们书写一个适用此情景的 SQL 映射语句。如果没有选择查询类别，则查询开始时间在今天之后的课程，<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;searchCourses&quot; parameterType=&quot;hashmap&quot; resultMap=&quot;CourseResult&quot;&gt;</span><br><span class="line">	SELECT * FROM COURSES</span><br><span class="line">	&lt;choose&gt;</span><br><span class="line">		&lt;when test=&quot;searchBy == &apos;Tutor&apos;&quot;&gt;</span><br><span class="line">			WHERE TUTOR_ID= #&#123;tutorId&#125;</span><br><span class="line">		&lt;/when&gt;</span><br><span class="line">		&lt;when test=&quot;searchBy == &apos;CourseName&apos;&quot;&gt;</span><br><span class="line">			WHERE name like #&#123;courseName&#125;</span><br><span class="line">		&lt;/when&gt;</span><br><span class="line">		&lt;otherwise&gt;</span><br><span class="line">			WHERE TUTOR start_date &gt;= now()</span><br><span class="line">		&lt;/otherwise&gt;</span><br><span class="line">	&lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>MyBatis 计算<choose>测试条件的值，且使用第一个值为 TRUE 的子句。如果没有条件为 true，则使用<otherwise>内的子句。</otherwise></choose></p>
<h3 id="Where-条件"><a href="#Where-条件" class="headerlink" title="Where 条件"></a>Where 条件</h3><p>有时候，所有的查询条件（criteria）应该是可选的。在需要使用至少一种查询条件的情况下，我们应该使用 WHERE子句。并且， 如果有多个条件，我们需要在条件中添加 AND 或 OR。MyBatis 提供了<code>&lt;where&gt;</code>元素支持这种类型的动态 SQL 语句。</p>
<p>在我们查询课程界面，我们假设所有的查询条件是可选的。进而，当需要提供一个或多个查询条件时，应该改使用WHERE 子句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;select id=&quot;searchCourses&quot; parameterType=&quot;hashmap&quot; resultMap=&quot;CourseResult&quot;&gt;</span><br><span class="line">	SELECT * FROM COURSES</span><br><span class="line">	&lt;where&gt;</span><br><span class="line">		&lt;if test=&quot; tutorId != null &quot;&gt;</span><br><span class="line">			TUTOR_ID= #&#123;tutorId&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;courseName != null&quot;&gt;</span><br><span class="line">			AND name like #&#123;courseName&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;startDate != null&quot;&gt;</span><br><span class="line">			AND start_date &gt;= #&#123;startDate&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;endDate != null&quot;&gt;</span><br><span class="line">			AND end_date &lt;= #&#123;endDate&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">	&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p><where>元素只有在其内部标签有返回内容时才会在动态语句上插入 WHERE 条件语句。并且，如果 WHERE 子句以AND 或者 OR 打头，则打头的 AND 或 OR 将会被移除。</where></p>
<p>如果 tutor_id 参数值为 null，并且 courseName 参数值不为 null，则<where>标签会将 AND name like#{courseName} 中的 AND 移除掉，生成的 SQL WHERE 子句为：where name like #{courseName}。</where></p>
<h3 id="lt-trim-gt-条件"><a href="#lt-trim-gt-条件" class="headerlink" title="&lt;trim&gt;条件"></a><code>&lt;trim&gt;</code>条件</h3><p><code>&lt;trim&gt;</code>元素和<code>&lt;where&gt;</code>元素类似，但是<code>&lt;trim&gt;</code>提供了在添加前缀/后缀 或者 移除前缀/后缀方面提供更大的灵活性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;searchCourses&quot; parameterType=&quot;hashmap&quot; resultMap=&quot;CourseResult&quot;&gt;</span><br><span class="line">	SELECT * FROM COURSES</span><br><span class="line">	&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND | OR&quot;&gt;</span><br><span class="line">		&lt;if test=&quot; tutorId != null &quot;&gt;</span><br><span class="line"> 			TUTOR_ID= #&#123;tutorId&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;courseName != null&quot;&gt;</span><br><span class="line">			AND name like #&#123;courseName&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">	&lt;/trim&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里如果任意一个<code>&lt;if&gt;</code>条件为 true，<code>&lt;trim&gt;</code>元素会插入 WHERE,并且移除紧跟 WHERE 后面的 AND 或 OR</p>
<h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><p>另外一个强大的动态 SQL 语句构造标签即是<code>&lt;foreach&gt;</code>。它可以迭代遍历一个数组或者列表，构造 AND/OR 条件或一个 IN 子句。</p>
<p>假设我们想找到 tutor_id 为 1，3，6 的讲师所教授的课程，我们可以传递一个 tutor_id 组成的列表给映射语句，然后通过<code>&lt;foreach&gt;</code>遍历此列表构造动态 SQL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;searchCoursesByTutors&quot; parameterType=&quot;map&quot; resultMap=&quot;CourseResult&quot;&gt;</span><br><span class="line">	SELECT * FROM COURSES</span><br><span class="line">	&lt;if test=&quot;tutorIds != null&quot;&gt;</span><br><span class="line">		&lt;where&gt;</span><br><span class="line">		&lt;foreach item=&quot;tutorId&quot; collection=&quot;tutorIds&quot;&gt;</span><br><span class="line">			OR tutor_id=#&#123;tutorId&#125;</span><br><span class="line">		&lt;/foreach&gt;</span><br><span class="line">		&lt;/where&gt;</span><br><span class="line">	&lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface CourseMapper &#123;</span><br><span class="line">	List&lt;Course&gt; searchCoursesByTutors(Map&lt;String, Object&gt; map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void searchCoursesByTutors()&#123;</span><br><span class="line">	Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">	List&lt;Integer&gt; tutorIds = new ArrayList&lt;Integer&gt;();</span><br><span class="line">	tutorIds.add(1);</span><br><span class="line">	tutorIds.add(3);</span><br><span class="line">	tutorIds.add(6);</span><br><span class="line">	map.put(&quot;tutorIds&quot;, tutorIds);</span><br><span class="line">	CourseMapper mapper = sqlSession.getMapper(CourseMapper.class);</span><br><span class="line">	List&lt;Course&gt; courses = mapper.searchCoursesByTutors(map);</span><br><span class="line">	for (Course course : courses) &#123;</span><br><span class="line">		System.out.println(course);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们来看一下怎样使用<foreach>生成 IN 子句：</foreach></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;searchCoursesByTutors&quot; parameterType=&quot;map&quot; resultMap=&quot;CourseResult&quot;&gt;</span><br><span class="line">	SELECT * FROM COURSES</span><br><span class="line">	&lt;if test=&quot;tutorIds != null&quot;&gt;</span><br><span class="line">		&lt;where&gt;</span><br><span class="line">			tutor_id IN</span><br><span class="line">				&lt;foreach item=&quot;tutorId&quot; collection=&quot;tutorIds&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">					#&#123;tutorId&#125;</span><br><span class="line">				&lt;/foreach&gt;</span><br><span class="line">		&lt;/where&gt;</span><br><span class="line">	&lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h3 id="set-条件"><a href="#set-条件" class="headerlink" title="set 条件"></a>set 条件</h3><p><code>&lt;set&gt;</code>元素和<code>&lt;where&gt;</code>元素类似，如果其内部条件判断有任何内容返回时，他会插入 SET SQL 片段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateStudent&quot; parameterType=&quot;Student&quot;&gt;</span><br><span class="line">	update students</span><br><span class="line">	&lt;set&gt;</span><br><span class="line">		&lt;if test=&quot;name != null&quot;&gt;name=#&#123;name&#125;,&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;phone != null&quot;&gt;phone=#&#123;phone&#125;,&lt;/if&gt;</span><br><span class="line">	&lt;/set&gt;</span><br><span class="line">	where stud_id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里，如果<code>&lt;if&gt;</code>条件返回了任何文本内容，<set>将会插入 set 关键字和其文本内容，并且会剔除将末尾的 “，。”<br>在上述的例子中，如果 phone!=null,<set>将会让会移除 phone=#{phone}后的逗号“,”，生成 set phone=#{phone} 。</set></set></p>
<h2 id="MyBaits-食谱"><a href="#MyBaits-食谱" class="headerlink" title="MyBaits 食谱"></a>MyBaits 食谱</h2><p>除了简化数据库编程外，MyBatis 还提供了各种功能，这些对实现一些常用任务非常有用，比如按页加载表数据，存取 CLOB/BLOB 类型的数据，处理枚举类型值，等等。让我们来看看其中一些特性吧。</p>
<h3 id="处理枚举类型"><a href="#处理枚举类型" class="headerlink" title="处理枚举类型"></a>处理枚举类型</h3><p>MyBatis 支持开箱方式持久化 enum 类型属性。假设 STUDENTS 表中有一列 gender（性别）类型为 varchar，存储”MALE”或者“FEMALE”两种值。并且，Student 对象有一个 enum 类型的 gender 属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">	FEMALE,</span><br><span class="line">	MALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，MyBatis 使用 EnumTypeHandler 来处理 enum 类型的 Java 属性，并且将其存储为 enum 值的名称。你不需要为此做任何额外的配置。你可以可以向使用基本数据类型属性一样使用 enum 类型属性，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String name;</span><br><span class="line">	private String email;</span><br><span class="line">	private PhoneNumber phone;</span><br><span class="line">	private Address address;</span><br><span class="line">	private Gender gender;</span><br><span class="line">	//setters and getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertStudent&quot; parameterType=&quot;Student&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">	insert into students(name,email,addr_id, phone,gender) values(#&#123;name&#125;,#&#123;email&#125;,#&#123;address.addrId&#125;,#&#123;phone&#125;,#&#123;gender&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<p>当你执行 insertStudent 语句的时候，MyBatis 会取 Gender 枚举（FEMALE/MALE）的名称，然后将其存储到 GENDER列中。</p>
<p>如果你希望存储原 enum 的顺序位置，而不是 enum 名，，你需要明确地配置它。</p>
<p>如 果 你 想 存 储 FEMALE 为 0 ， MALE 为 1 到 gender 列 中 ， 你 需 要 在 mybatis-config.xml 文 件 中 配 置EnumOrdinalTypeHandler:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;org.freecode.domain.Gender&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用顺序位置为值存储到数据库时要当心。顺序值是根据 enum 中的声明顺序赋值的。如果你改变了 Gender enum 的声明顺序，则数据库存储的数据和此顺序值就不匹配了。</p>
<h3 id="处理-CLOB-BLOB-类型数据"><a href="#处理-CLOB-BLOB-类型数据" class="headerlink" title="处理 CLOB/BLOB 类型数据"></a>处理 CLOB/BLOB 类型数据</h3><p>MyBatis 提供了内建的对 CLOB/BLOB 类型列的映射处理支持。</p>
<p>假设我们有如下的表结构来存储学生和讲师的照片和简介信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USER_PICS</span><br><span class="line">(</span><br><span class="line">ID INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(50) DEFAULT NULL,</span><br><span class="line">PIC BLOB,</span><br><span class="line">BIO LONGTEXT,</span><br><span class="line">PRIMARY KEY (ID)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=LATIN1;</span><br></pre></td></tr></table></figure></p>
<p>这里，照片可以是 PNG,JPG 或其他格式的。简介信息可以是学生或者讲师的漫长的人生经历。默认情况下，MyBatis将 CLOB 类型的列映射到 java.lang.String 类型上、而把 BLOB 列映射到 byte[] 类型上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class UserPic &#123;</span><br><span class="line">	private int id;</span><br><span class="line">	private String name;</span><br><span class="line">	private byte[] pic;</span><br><span class="line">	private String bio;</span><br><span class="line">	//setters &amp; getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 UserPicMapper.xml 文件，配置映射语句，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertUserPic&quot; parameterType=&quot;UserPic&quot;&gt;</span><br><span class="line">	INSERT INTO USER_PICS(NAME, PIC,BIO) VALUES(#&#123;name&#125;,#&#123;pic&#125;,#&#123;bio&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;select id=&quot;getUserPic&quot; parameterType=&quot;int&quot; resultType=&quot;UserPic&quot;&gt;</span><br><span class="line">	SELECT * FROM USER_PICS WHERE ID=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>下列的 insertUserPic()展示了如何将数据插入到 CLOB/BLOB 类型的列上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void insertUserPic() &#123;</span><br><span class="line">	byte[] pic = null;</span><br><span class="line">	try &#123;</span><br><span class="line">		File file = new File(&quot;C:\\Images\\UserImg.jpg&quot;);</span><br><span class="line">		InputStream is = new FileInputStream(file);</span><br><span class="line">		pic = new byte[is.available()];</span><br><span class="line">		is.read(pic);</span><br><span class="line">		is.close();</span><br><span class="line">	&#125;catch (FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;catch (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">	String name = &quot;UserName&quot;;</span><br><span class="line">	String bio = &quot;put some lenghty bio here&quot;;</span><br><span class="line">	UserPic userPic = new UserPic(0, name, pic , bio);</span><br><span class="line">	SqlSession sqlSession = MyBatisUtil.openSession();</span><br><span class="line">	try &#123;</span><br><span class="line">		UserPicMapper mapper = sqlSession.getMapper(UserPicMapper.class);</span><br><span class="line">		mapper.insertUserPic(userPic);</span><br><span class="line">		sqlSession.commit();</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		sqlSession.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的 getUserPic()方法展示了怎样将 CLOB 类型数据读取到 String 类型，BLOB 类型数据读取成 byte[]属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void getUserPic() &#123;</span><br><span class="line">	UserPic userPic = null;</span><br><span class="line">	SqlSession sqlSession = MyBatisUtil.openSession();</span><br><span class="line">	try &#123;</span><br><span class="line">		UserPicMapper mapper = sqlSession.getMapper(UserPicMapper.class);</span><br><span class="line">		userPic = mapper.getUserPic(1);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		sqlSession.close();</span><br><span class="line">	&#125;</span><br><span class="line">	byte[] pic = userPic.getPic();</span><br><span class="line">	try &#123;</span><br><span class="line">		OutputStream os = new FileOutputStream(new File(&quot;C:\\Images\\UserImage_FromDB.jpg&quot;));</span><br><span class="line">		os.write(pic);</span><br><span class="line">		os.close();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传入多个输入参数"><a href="#传入多个输入参数" class="headerlink" title="传入多个输入参数"></a>传入多个输入参数</h3><p>MyBatis 中的映射语句有一个 parameterType 属性来制定输入参数的类型。如果我们想给映射语句传入多个参数的话，我们可以将所有的输入参数放到 HashMap 中，将 HashMap 传递给映射语句。</p>
<p>MyBatis 还提供了另外一种传递多个输入参数给映射语句的方法。假设我们想通过给定的 name 和 email 信息查找学生信息，定义查询接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Public interface StudentMapper &#123;</span><br><span class="line">	List&lt;Student&gt; findAllStudentsByNameEmail(String name, String email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MyBatis 支持 将多个输入参数传递给映射语句，并以#{param}的语法形式引用它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findAllStudentsByNameEmail&quot; resultMap=&quot;StudentResult&quot;&gt;</span><br><span class="line">	select stud_id, name,email, phone from Students where name=#&#123;param1&#125; and email=#&#123;param2&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里#{param1}引用第一个参数 name，而#{param2}引用了第二个参数 email。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">studentMapper.findAllStudentsByNameEmail(name, email);</span><br></pre></td></tr></table></figure></p>
<h3 id="多行结果集映射成-Map"><a href="#多行结果集映射成-Map" class="headerlink" title="多行结果集映射成 Map"></a>多行结果集映射成 Map</h3><p>如果你有一个映射语句返回多行记录，并且你想以 HashMap 的形式存储记录的值，使用记录列名作为 key 值，而记录对应值或为 value 值。我们可以使用 sqlSession.selectMap(),如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot; findAllStudents&quot; resultMap=&quot;StudentResult&quot;&gt;</span><br><span class="line">	select * from Students</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Student&gt; studentMap = sqlSession.selectMap(&quot;org.freecode.mappers.StudentMapper.findAllStudents&quot;, &quot;studId&quot;);</span><br></pre></td></tr></table></figure>
<p>这里 studentMap 将会将 studId 作为 key 值，而 Student 对象作为 value 值。</p>
<h3 id="使用-RowBounds-对结果集进行分页"><a href="#使用-RowBounds-对结果集进行分页" class="headerlink" title="使用 RowBounds 对结果集进行分页"></a>使用 RowBounds 对结果集进行分页</h3><p>有时候，我们会需要跟海量的数据打交道，比如一个有数百万条数据级别的表。由于计算机内存的现实我们不可能一次性加载这么多数据，我们可以获取到数据的一部分。特别是在 Web 应用程序中，分页机制被用来以一页一页的形式展示海量的数据。</p>
<p>MyBatis 可以使用 RowBounds 逐页加载表数据。RowBounds 对象可以使用 offset 和 limit 参数来构建。参数offset 表示开始位置，而 limit 表示要取的记录的数目。假设如果你想每页加载并显示 25 条学生的记录，你可以使用如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findAllStudents&quot; resultMap=&quot;StudentResult&quot;&gt;</span><br><span class="line">	select * from Students</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后，你可以加载如下加载第一页数据（前 25 条）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int offset =0 , limit =25;</span><br><span class="line">RowBounds rowBounds = new RowBounds(offset, limit);</span><br><span class="line">List&lt;Student&gt; = studentMapper.getStudents(rowBounds);</span><br></pre></td></tr></table></figure></p>
<p>若要展示第二页，使用 offset=25,limit=25;第三页，则为 offset=50，limit=25。</p>
<h3 id="使用-ResultSetHandler-自定义结果集-ResultSet-处理"><a href="#使用-ResultSetHandler-自定义结果集-ResultSet-处理" class="headerlink" title="使用 ResultSetHandler 自定义结果集 ResultSet 处理"></a>使用 ResultSetHandler 自定义结果集 ResultSet 处理</h3><p>MyBatis 在将查询结果集映射到 JavaBean 方面提供了很大的选择性。但是，有时候我们会遇到由于特定的目的，需要我们自己处理 SQL 查询结果的情况。MyBatis 提供了 ResultHandler 插件形式允许我们以任何自己喜欢的方式处理结果集 ResultSet。</p>
<p>  假设我们想从学生的 stud_id 被用作 key，而 name 被用作 value 的 HashMap 中获取到 student 信息。</p>
<blockquote>
<p>mybatis-3.2.2 并不支持使用 resultMap 配置将查询的结果集映射成一个属性为key，而另外属性为 value 的 HashMap。<br>sqlSession.selectMap()则可以返回 以给定列为 key，记录对象为 value 的 map。<br>我们不能将其配置成使用其中一个属性作为 key，而另外的属性作为 value。</p>
</blockquote>
<p>对于 sqlSession.select()方法，我们可以传递给它一个 ResultHandler 的实现，它会被调用来处理 ResultSet的每一条记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ResultHandler &#123;</span><br><span class="line">	void handleResult(ResultContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在然我们来看一下怎么使用 ResultHandler 来处理结果集 ResultSet，并返回自定义化的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;Integer, String&gt; getStudentIdNameMap() &#123;</span><br><span class="line"></span><br><span class="line">	final Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();</span><br><span class="line">	SqlSession sqlSession = MyBatisUtil.openSession();</span><br><span class="line">	try &#123;</span><br><span class="line">	sqlSession.select(&quot;org.freecode.mappers.StudentMapper.findAllStudents&quot;, new ResultHandler()&#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void handleResult(ResultContext context) &#123;</span><br><span class="line">			Student student = (Student) context.getResultObject();</span><br><span class="line">			map.put(student.getStudId(), student.getName());</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		sqlSession.close();</span><br><span class="line">	&#125;</span><br><span class="line">	return map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 上 述 的 代 码 中 ， 我 们 提 供 了 匿 名 内 部 ResultHandler 实 现 类 ， 在 handleResult() 方 法 中 ， 我 们 使 用context.getResultObject()获取当前的 result 对象，即 Student 对象，因为我们定义了 findAllStudent 映射语句的 resultMap=”studentResult“。对查询返回的每一行都会调用 handleResult()方法，并且我们从 Student 对象中取出 studId 和 name，将其放到 map 中。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>将从数据库中加载的数据缓存到内存中，是很多应用程序为了提高性能而采取的一贯做法。MyBatis 对通过映射的SELECT 语句加载的查询结果提供了内建的缓存支持。默认情况下，启用一级缓存；即，如果你使用同一个 SqlSession接口对象调用了相同的 SELECT 语句，则直接会从缓存中返回结果，而不是再查询一次数据库。</p>
<p>我们可以在 SQL 映射器 XML 配置文件中使用<code>&lt;cache /&gt;</code>元素添加全局二级缓存。<br>当你加入了<code>&lt;cache /&gt;</code>元素，将会出现以下情况：</p>
<ul>
<li>所有的在映射语句文件定义的<code>&lt;select&gt;</code>语句的查询结果都会被缓存</li>
<li>所有的在映射语句文件定义的<code>&lt;insert&gt;</code>,<code>&lt;update&gt;</code> 和<code>&lt;delete&gt;</code>语句将会刷新缓存</li>
<li>缓存根据最近最少被使用（Least Recently Used，LRU）算法管理</li>
<li>缓存不会被任何形式的基于时间表的刷新（没有刷新时间间隔），即不支持定时刷新机制</li>
<li>缓存将存储 1024 个 查询方法返回的列表或者对象的引用</li>
<li>缓存会被当作一个读/写缓存。这是指检索出的对象不会被共享，并且可以被调用者安全地修改，不会其他潜在的调用者或者线程的潜在修改干扰。（即，缓存是线程安全的）</li>
</ul>
<p>你也可以通过复写默认属性来自定义缓存的行为，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>以下是对上述属性的描述：</p>
<ul>
<li>eviction:此处定义缓存的移除机制。默认值是 LRU，其可能的值有：LRU（least recently used,最近最少使用）,FIFO(first in first out,先进先出)，SOFT(soft reference,软引用)，WEAK（weakreference,弱引用）。</li>
<li>flushInterval:定义缓存刷新间隔，以毫秒计。默认情况下不设置。所以不使用刷新间隔，缓存 cache 只有调用语句的时候刷新。</li>
<li>size:此表示缓存 cache 中能容纳的最大元素数。默认值是 1024，你可以设置成任意的正整数。</li>
<li>readOnly:一个只读的缓存 cache 会对所有的调用者返回被缓存对象的同一个实例（实际返回的是被返回对象的一份引用）。一个读/写缓存 cache 将会返回被返回对象的一分拷贝（通过序列化）。默认情况下设置为 false。可能的值有 false 和 true。</li>
</ul>
<p>一个缓存的配置和缓存实例被绑定到映射器配置文件所在的名空间（namespace）上，所以在相同名空间内的所有语句被绑定到一个 cache 中。<br>80</p>
<p>默认的映射语句的 cache 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select ... flushCache=&quot;false&quot; useCache=&quot;true&quot;/&gt;</span><br><span class="line">&lt;insert ... flushCache=&quot;true&quot;/&gt;</span><br><span class="line">&lt;update ... flushCache=&quot;true&quot;/&gt;</span><br><span class="line">&lt;delete ... flushCache=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>你可以为任意特定的映射语句复写默认的 cache 行为；例如，对一个 select 语句不使用缓存，可以设置useCache=“false”。</p>
<p>除了内建的缓存支持，MyBatis 也提供了与第三方缓存类库如 Ehcache，OSCache，Hazelcast 的集成支持。你可以在 MyBatis 官方网站 <a href="https://code.google.com/p/mybatis/wiki/Caches" target="_blank" rel="external">https://code.google.com/p/mybatis/wiki/Caches</a> 上找到关于继承第三方缓存类库的更多信息。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/MyBatis/" rel="tag">#MyBatis</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/04/02/2014/MyBatis井号和$的区别/" rel="next" title="Mybatis ${}和#{} 区别">
                <i class="fa fa-chevron-left"></i> Mybatis ${}和#{} 区别
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/04/04/2014/MyBatis 与 第三方框架集成/" rel="prev" title="MyBatis 与 第三方框架集成">
                MyBatis 与 第三方框架集成 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2014/04/03/2014/MyBatis 使用XML配置SQL 映射器/"
           data-title="MyBatis 使用XML配置SQL 映射器" data-url="http://cmp-cc.github.io/2014/04/03/2014/MyBatis 使用XML配置SQL 映射器/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="cmp-cc" />
          <p class="site-author-name" itemprop="name">cmp-cc</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">56</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cmp-cc" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#映射器配置文件和映射器接口"><span class="nav-number">1.</span> <span class="nav-text">映射器配置文件和映射器接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#映射语句"><span class="nav-number">2.</span> <span class="nav-text">映射语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#INSERT-语句"><span class="nav-number">2.1.</span> <span class="nav-text">INSERT 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UPDATE-语句"><span class="nav-number">2.2.</span> <span class="nav-text">UPDATE 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DELETE-语句"><span class="nav-number">2.3.</span> <span class="nav-text">DELETE 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELECT-语句"><span class="nav-number">2.4.</span> <span class="nav-text">SELECT 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结果集映射-ResultMaps"><span class="nav-number">3.</span> <span class="nav-text">结果集映射 ResultMaps</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单-ResultMap"><span class="nav-number">3.1.</span> <span class="nav-text">简单 ResultMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓展-ResultMap"><span class="nav-number">3.2.</span> <span class="nav-text">拓展 ResultMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一对一映射"><span class="nav-number">4.</span> <span class="nav-text">一对一映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用嵌套结果-ResultMap-实现一对一关系映射"><span class="nav-number">4.1.</span> <span class="nav-text">使用嵌套结果 ResultMap 实现一对一关系映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用嵌套查询实现一对一关系映射"><span class="nav-number">4.2.</span> <span class="nav-text">使用嵌套查询实现一对一关系映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一对多映射"><span class="nav-number">5.</span> <span class="nav-text">一对多映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用内嵌结果-ResultMap-实现一对多映射"><span class="nav-number">5.1.</span> <span class="nav-text">使用内嵌结果 ResultMap 实现一对多映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用嵌套-Select-语句实现一对多映射"><span class="nav-number">5.2.</span> <span class="nav-text">使用嵌套 Select 语句实现一对多映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态-SQL"><span class="nav-number">6.</span> <span class="nav-text">动态 SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#If-条件"><span class="nav-number">6.1.</span> <span class="nav-text">If 条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#choose-when-和-otherwise-条件"><span class="nav-number">6.2.</span> <span class="nav-text">choose,when 和 otherwise 条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Where-条件"><span class="nav-number">6.3.</span> <span class="nav-text">Where 条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-trim-gt-条件"><span class="nav-number">6.4.</span> <span class="nav-text"><trim>条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#foreach-循环"><span class="nav-number">6.5.</span> <span class="nav-text">foreach 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-条件"><span class="nav-number">6.6.</span> <span class="nav-text">set 条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBaits-食谱"><span class="nav-number">7.</span> <span class="nav-text">MyBaits 食谱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理枚举类型"><span class="nav-number">7.1.</span> <span class="nav-text">处理枚举类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理-CLOB-BLOB-类型数据"><span class="nav-number">7.2.</span> <span class="nav-text">处理 CLOB/BLOB 类型数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传入多个输入参数"><span class="nav-number">7.3.</span> <span class="nav-text">传入多个输入参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多行结果集映射成-Map"><span class="nav-number">7.4.</span> <span class="nav-text">多行结果集映射成 Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-RowBounds-对结果集进行分页"><span class="nav-number">7.5.</span> <span class="nav-text">使用 RowBounds 对结果集进行分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-ResultSetHandler-自定义结果集-ResultSet-处理"><span class="nav-number">7.6.</span> <span class="nav-text">使用 ResultSetHandler 自定义结果集 ResultSet 处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">7.7.</span> <span class="nav-text">缓存</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cmp-cc</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cmp-cc"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();


  </script>

  
    
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  

 <script type="text/javascript">
  window.onload = function(){setTimeout(function(){/*无登陆账户*/if(!document.getElementsByClassName("ds-account-control")[0]){var cmp_cc_blog_user=localStorage.getItem("cmp-cc_blog_user");var author_name_value = cmp_cc_blog_user?'value="'+cmp_cc_blog_user+'"':'';var i = '<div class="ds-control-group" style="float:right;padding:6px;"><input type="text" '+author_name_value+'id="author_name_proxy" id="ds-dialog-name"  class="custom_input" style="color:#777;width=80%;font-size:13px;border:1px solid #ccc;height:25px;box-shadow: inset 0 1px 1px;padding: 2px 0px 0px 8px;" placeholder="昵称 or 登陆" required></div>';/*展开一个回复，再关闭。 多说没有参数配置啊~ 让人觉得不优雅*/var $last_ds_post_reply = $(".ds-post-reply:last");$last_ds_post_reply.click().click();$(".ds-post-options.ds-gradient-bg").append(i);$(".ds-post-button").click(function(){$(this).submit();$("#ds-wrapper").hide();var author_name = $("#author_name_proxy").val();$("#ds-wrapper #ds-dialog-name").val(author_name);$("#ds-wrapper form").submit();/*www.cmp-cc.github.com*/localStorage.setItem("cmp-cc_blog_user",author_name);$(".custom_input").val(author_name);});}},300);} 
 </script>





  
  
  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
